---
title: "이펙티브 자바 2강"
categories:
  - java
tags:
  - effective java
toc: true
toc_sticky: true
toc_label: ""
toc_icon: ""
---

이펙티브 자바를 보고 정리한 글 입니다. 

---

### 생성자 대신 정적 팩토리 메서드를 고려하라

- 정적 팩토리 메서드 : 클래스의 인스턴스를 반환하는 단순한 정적 메서드
- 장점
  - 이름을 가질 수 있다.
  - 호출 될 때마다 인스턴스를 새로 생성하지 않아도 된다.
  - 반환 타입의 하위 타입의 객체를 반환할 수 있는 능력이 있다.
  - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
  - 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
- 단점
  - 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.
  - 정적 팩토리 메서드는 프로그래머가 찾기 힘들다.
- 명명 방식
  - **from** : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드

    ex) Date d = Date. from(instant);

  - **of**: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
    ex) Set<Rank> FaceCards = EnumSet.of (JACK, QUEEN, KING);
  - **valueof**: from과 of의 더 자세한 버전
    ex) BigInteger prime = BigInteger.valueOf (Integer.MAX_VALUE);
  - **instance** 혹은 **getInstance**: (매개변수를 받는다면) 매개변수로 명시한 인 스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
    ex) StackWalker luke = StackWalker.getInstance(options);
  - **create** 혹은 **newInstance**: instance 혹은 getInstance와 같지만, 매번 새로 운 인스턴스를 생성해 반환함을 보장한다.
    ex) Object newArray = Array-newInstance(classObject, arrayLen);
  - **getType**: getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터 리 메서드를 정의할 때 쓴다. "Type"은 팩터리 메서드가 반환할 객체의 타입 이다.
    ex) FileStore fs = Files.getFileStore(path)
  - **newType**: newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터 리 메서드를 정의할 때 쓴다. "Type"은 팩터리 메서드가 반환할 객체의 타입 이다.
    ex) BufferedReader br = Files.newBufferedReader(path);
  - **type**: getType과 newType의 간결한 버전
    ex) List<Complaint> litany = Collections. list(legacyLitany);
- 핵심 정리
  - 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이 해하고 사용하는 것이 좋다. 그렇다고 하더라도 정적 팩터리를 사용하는 게 유리한 경우 가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자

### 생성자에 매개변수가 많다면 빌더를 고려하라

- 점층적 생성자 패턴도 쓸 수 있지만, 매개변수가 많아질수록 클라이언트 코드를 작성하거나 읽기 힘들다.
- 자바빈즈 패턴(setter)에서는 객체 하나를 만들려면 메서드 여러개를 호출해야 하고, 객체가 완전히 생성되기 전 까지는 일관성이 무너진 상태에 놓이게 됨, 또한 자바빈즈 패턴에서는 클래스를 불변아이템으로 만들 수 없으며 쓰레드 안정성을 얻으려면 프로그래머가 추가 작업을 해줘야만 한다.
- 빌더의 세터 메서드들은 빌더 자신을 반환하기 때문에 연쇄적으로 호출 할 수 있다. 이런 방식을 메서드 호출이 흐르듯 연결된다는 뜻으로 플루언트 APT(fuent API) 혹은 메서드 연쇄(method chaining)라 한다. 다음은 이 클래스 를 사용하는 클라이언트 코드의 모습이다. 코드는 쓰기 쉽고, 무엇보다도 읽기 쉽다. 빌더 패턴은 (파이썬 과 스칼라에 있는) 명명된 선택적 매개변수(named optional parameters)를 흉 내 낸 것이다.

```java
NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
                     .calories(100).sodium(35).carbohydrate(27).build();
```

- 빌더패턴은 계층적으로 설계된 클래스와 함께 쓰기 좋다.
- 핵심 정리
  - 생성자나 정적 팩토리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는게 낫다. 매개변수 중 다수가 필드가 아니거나 같은 타입이면 특히 더 그렇다. 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨신 간결하고, 자바빈즈 보다 더 안전하다

### private 생성자나 열거 타입으로 싱글턴임을 보증하라

- 싱글턴이란? 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.
- 생성 방법 case 1) public static final 필드 방식의 싱글턴

```java
public class Elvis {
	**public static final Elvis INSTANCE = new Elvis();**
	private Elvis() { ... }

	public void leaveTheBuilding() { ... }
}
```

- 생성방법 case 2) 정적 팩토리 방식의 싱글턴

```java
public class Elvis {
	private static final Elvis INSTANCE = new Elvis();
	private Elvis () { ... }
	**public static Elvis getInstance() { return INSTANCE; }**

	public void leaveTheBuilding() { ... }
}
```

- 생성방법 case 3) 열거 타입 방식의 싱글턴 - 바람직한 방법

```java
public enum Elvis {
	**INSTANCE;**
	public void leaveTheBuilding() { ...}
}
```

- 대부분의 상황에서는 원소가 하나뿐인 열거타입이 싱글턴을 만드는 가장 좋은 방법이다.

### 인스턴스화를 막으려거든 private 생성자를 사용하라

- 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어준다. 즉, 매개변수를 받지 않는 public 생성자가 만들어지며, 사용자는 이 생성자가 자동 생성된 것인지 구분할 수 없다. 실제로 공개된 API들에서도 이처럼 의도치 않게 인스턴스화할 수 있게 된 클래스가 종종 목격되곤 한다.
  추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.