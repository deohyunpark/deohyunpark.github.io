---
title: "이펙티브자바 7장  - 람다와 스트림"
categories:
  - java
tags:
  - effective java
toc: true
toc_sticky: true
toc_label: ""
toc_icon: ""
---

이펙티브 자바를 보고 정리한 글 입니다. 

---
# 람다와 스트림

### 익명 클래스보다는 람다를 사용하라

- 익명 클래스의 인스턴스를 함수 객체로 사용 - 낡은 기법

```java
Collections.sort(words, new Comparator<String>() {
	public int compare(String s1, String s2) {
		return Integer.compare(s1. length(), s2. length ());
		}
}) ;
```

- 람다식을 함수 객체로 사용 - 익명 클래스 대체

```java
Collections.sort (words,
	(s1, s2) → Integer. compare(s1.length(), s2.length())) ;
```

여기서 람다, 매개변수(s1, s2), 반환값의 타입은 각각 (Comparator<String>), string, Int지만 코드에서는 언급이 없다. 우리 대신 컴파일러가 문맥을 살펴 타입을 추론해준 것이다. 상황에 따라 컴파일러가 타입을 결정하지 못할 수도 있는데, 그럴 때는 프로그래머가 직접 명시해야 한다. 타입 추론 규칙은 자바 언어 명세의 장(chapter) 하나를 통째로 차지할 만큼 복잡하다. 이 규칙을 다 이해하는 프로그래머는 거의 없고, 잘 알지 못한다 해도 상관없다. **타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자**

- 열거 타입의 인스턴스 필드를 이용하는 방식으로 상수별로 다르게 동작하는 코드 를 쉽게 구현할 수 있다. 단순히 가 열거 타입 상수의 동작을 람다로 구현해 생 성자에 넘기고, 생성자는 이 다를 인스턴스 필드로 저장해둔다. 그런 다음 apply 메서드에서 필드에 저장된 람다를 호출하기만 하면 된다. 이렇게 구현하 면 원래 버전보다 간결하고 깔끔해진다.

```java
public enum Operation {
	PLUS ("+", (x, y) -> x + y)
	MINUS ("-", (x, y) -> x - y),
	TIMES ("*", (x, y) -> x * y),
	DIVIDE（"/", (x, y) -> x / y）;

	private final String symbol; 
	private final DoubleBinaryOperator op;

	Operation(String symbol, DoubleBinaryOperator op) {
		this.symbol = symbol;
		this.op = op;
	}

	@Override public String toString() { return symbol; } 
	public double apply(double x, double y) {
		 return op.applyAsDouble(x, y);
		}
}
```

- **람다는 이름이 없고 문서화도 못 한다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.** 람다는 한 줄 일피 가장 좋고 걸어야 세 줄 안에 끝내는 게 좋다. 세 줄을 넘어가면 가독성 이 심하게 나빠진다. 랍다가 걸거나 읽기 어렵다면 더 간단히 줄여보거나 람다 부쓰지 않는 쪽으로 리팩터링하길 바란다.
- 람다를 직렬화하는 일은 극히 삼가야 한다.
  1. **람다의 내부 구현이 익명 클래스로 변환되기 때문:**
    - 람다 표현식은 내부적으로 익명 클래스로 변환되어 동작합니다. 이 익명 클래스의 내부 상태 및 동작을 직렬화하려면 해당 익명 클래스가 명시적으로 선언된 클래스로 정의되어야 합니다. 하지만 람다의 익명 클래스는 컴파일러에 의해 자동으로 생성되며, 클래스의 이름이나 구조가 람다 표현식의 컨텍스트에 의존하게 됩니다.
  2. **람다의 환경 캡처(Capture of Environment) 어려움:**
    - 람다는 주변 범위(outer scope)에서 자유롭게 변수를 참조할 수 있습니다. 이러한 환경 캡처는 람다가 생성된 시점에 해당 시점의 변수를 참조하게 됩니다. 하지만 람다를 직렬화하고 다른 컨텍스트에서 복원할 때 해당 환경이 어떻게 캡처되었는지 정확하게 복원하는 것은 어려움이 따릅니다.

### 람다보다는 메서드 참조를 사용하라

```java
service.execute(GoshThisClassNameIsHumongous::action);
//이를 람다로 대체하면 다음처럼 된다.
service.execute(() -> action());
```

- 메서드 참조 쪽은 더 짧지도, 더 명확하지도 않다. 따라서 람다 쪽이 낫다. 같은 신상에서 Java.util.function 패키지가 제공하는 제네릭 정적 팩터리 메서드인  Function.Identity()를 사용하기보다는 똑같은 기능의 람다(x → y)를 직접 사용하는 편이 코드도 짧고 명확하다.
- 클래스 생성자를 가리키는 메서드 참조와 배열 생성자를 가리 키는 메서드 참조가 있다. 생성자 참조는 팩토리 객체로 사용된다.다음은 이상의 다섯 가지 메서드 참조를 정리한 표다.

| 메서드 참조 유형 | 예 | 같은기능을 하는 람다 |
| --- | --- | --- |
| 정적 | Integer::parseInt | str → Integer.parseInt(str) |
| 한정적(인스턴스) | Instant.now()::isAfter | Instant then = Instant.now();
t → then.isAfter(t) |
| 비한정적(인스턴스) | String::toLowerCase | str → str.toLowerCase() |
| 클래스 생성자 | TreeMap<K,V>::new | () → new TreeMap<K,V>() |
| 배열 생성자 | int[]::new | len → new int[len] |
- 핵심정리
  - 메서드 참조는 람다의 간단명료한 대안이 될 수 있다. 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을때만 람다를 사용하라.

### 표준 함수형 인터페이스를 사용하라

- 필요한 용도에 맞는게 있다면, 직접 구현하지말고 표준 함수형 인터페이스를 활용하라
- 함수형 인터페이스 정리
  1. **`Supplier<T>`:**
    - 제네릭 타입 **`T`**의 값을 제공하는 함수형 인터페이스. **`get`** 메서드를 통해 값을 제공.

        ```java
        @FunctionalInterface
        public interface Supplier<T> {
            T get();
        }
        ```

1. **`Consumer<T>`:**
  - 제네릭 타입 **`T`**의 값을 받아 소비하는 함수형 인터페이스. **`accept`** 메서드를 통해 값을 소비.

      ```java
      @FunctionalInterface
      public interface Consumer<T> {
      void accept(T t);
      }
      ```

2. **`Function<T, R>`:**
  - 제네릭 타입 **`T`**의 값을 받아서 제네릭 타입 **`R`**로 매핑하는 함수형 인터페이스. **`apply`** 메서드를 통해 매핑을 수행.

      ```java
      @FunctionalInterface
      public interface Function<T, R> {
          R apply(T t);
      }
      ```

3. **`Predicate<T>`:**
- 제네릭 타입 **`T`**의 값을 받아서 어떤 조건에 맞는지 확인하는 함수형 인터페이스. **`test`** 메서드를 통해 조건을 확인.

    ```java
    @FunctionalInterface
    public interface Predicate<T> {
        boolean test(T t);
    }
    ```

1. **`BiFunction<T, U, R>`:**
- 두 개의 제네릭 타입 **`T`**와 **`U`**를 받아서 제네릭 타입 **`R`**로 매핑하는 함수형 인터페이스. **`apply`** 메서드를 통해 매핑을 수행.

    ```java
    @FunctionalInterface
    public interface BiFunction<T, U, R> {
        R apply(T t, U u);
    }
    ```


이 외에도 다양한 함수형 인터페이스가 **`java.util.function`** 패키지에 정의되어 있습니다. 이러한 인터페이스들은 함수형 프로그래밍에서 다양한 역할을 수행하며, 람다 표현식이나 메서드 참조와 함께 사용됩니다.

### 스트림은 주의해서 사용하라

- 스트림(stream)은 데이터 원소의 유한 혹은 무한 시퀀스(sequence)를 뜻한다. 두 번째인 스트림 파이프라인(Steam pipeline)은 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.
- 스트림 API는 다재다능하여 사실상 어떠한 계산이라도 해낼 수 있다. 하지만 할 수 있다는 뜻이지, 해야 한다는 뜻은 아니다. **스트림을 제대로 사용하면 프로그램이 짧고 깔끔해지지만, 잘못 사용하면 읽기 어렵고 유지보수도 힘들어 진다.**
- 스트림으로 바꾸는 게 가능할지라도 코드 가독성과 유지보수 측면에서는 손해를 볼 수 있다. 스트림과 반복문을 적절히 조합하는 게 최선이다. 그러니 기존 코드는 스트림을 사용하도록 리펙터링하되, 새 코드가 더 나아 보일 때만 반영하자.
- 스트림 파이프라인은 되풀이되는 계산을 함수 객체(주로 람다나 메서드 참조)로 표현한다. 반면 반복 코드에 서는 코드 블록을 사용해 표현한다. 그런데 함수 객체로는 할 수 없지만 코드 블록으로는 할 수 있는 일들이 있으니, 다음이 그 예다.
  - 코드 블록에서는 범위 안의 지역변수를 읽고 수정할 수 있다. 하지만 람다 에서는 final이거나 사실상 final인 변수ULS 4.12.4만 읽을 수 있고, 지역변 수를 수정하는 건 불가능하다.
  - 코드 블록에서는 return 문을 사용해 메서드에서 빠져나가거나, break나
    continue 문으로 블록 바깥의 반복문을 종료하거나 반복을 한 번 건너뛸 수 있다. 또한 메서드 선언에 명시된 검사 예외를 던질 수 있다. 하지만 람다로 는 이 중 어떤 것도 할 수 없다.
- 계산 로직에서 이상의 일들을 수행해야 한다면 스트림과는 맞지 않는 것이다.
  반대로 다음 일들에는 스트림이 아주 안성맞춤이다.
  - 원소들의 시퀀스를 일관되게 변환한다.
  - 원소들의 시퀀스를 필터링한다.
  - 원소들의 시퀀스를 하나의 연산을 사용해 결합한다(더하기, 연결하기, 최솟값구하기 등)
  - 원소들의 시퀀스를 전렉션에 모은다(아마도 공통된 속성을 기준으로 묶어가며)
  - 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.
- 데카르트 곱 계산을 스트림 방식으로 구현

```java
private static List<Card> newDeck() {
	return Stream.of(Suit.values())
			.flatMap(suit ->
					Stream.of(Rank.values())
						.map(**rank →> new Card**(suit, rank)))
			.collect(toList());
}
```

- 핵심 정리
  - 스트림을 사용해야 멋지게 처리할 수 있는 일이 있고, 반복 방식이 더 알맞은 일도 있다. 그리고 수많은 작업이 이 둘을 조합했을 때 가장 멋지게 해결된다. 어느 쪽을 선택하는 확고부동한 규칙은 없지만 참고할 만한 지침 정도는 있다. 어느 쪽이 나은지가 확연히 드러나는 경우가 많겠지만, 아니더라도 방법은 있다. 스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하라.

### 스트림에서는 부작용 없는 함수를 사용하라

- forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산할때는 쓰지말자
- 핵심정리
  - 스트림 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체에 있다. 스트림뿐 아니 라 스트림 관련 객체에 건네지는 모든 함수 객체가 부작용이 없어야 한다. 종단 연산 중 forEach는 스트림이 수행한 계산 결과를 보고할 때만 이용해야 한다. 계산 자체에는 이 용하지 말자. 스트림을 올바로 사용하려면 수집기를 잘 알아둬야 한다. 가장 중요한 수집기 팩토리는 toList, toSet, toMap, groupingBy, joining 이다.

### 반환타입으로는 스트림보다 컬렉션이 낫다.

- 핵심정리
  - 원소 시퀀스를 반환하는 메서드를 작성할 때는, 이를 스트림으로 처리하기를 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있음을 떠올리고, 양쪽을 다 만족시키려 노력하자. 컬렉션을 반환할 수 있다면 그렇게 하라. 반환 전부터 이미 원소 들을 컬렉션에 담아 관리하고 있거나 컬렉션을 하나 더 만들어도 될 정도로 원소 개수가 적다면 ArrayList 같은 표준 컬렉션에 담아 반환하라. 그렇지 않으면 앞서의 멱집합 예처럼 전용 컬렉션을 구현할지 고민하라. 컬렉션을 반환하는 게 불가능하면 스트림과 Iterable 중 더 자연스러운 것을 반환하라. 만약 나중에 Stream 인터페이스가 Iterable을 지원하도록 자바가 수정된다면, 그때는 안심하고 스트림을 반환하면 될 것 이다(스트림 처리와 반복 모두에 사용할 수 있으니).


### 스트림 병렬화는 주의해서 적용하라

- 데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다
- 대체로 스트림의 소스가 ArrayList, HashMap, Hashset, ConcurrentHashtap 의 인스턴스거나 배열, int 범위, Long 범위일 때 병렬화의 효과가 가장 좋 다. 이 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 일을 다수의 스레드에 분배하기에 좋다는 특징이 있다.
- 스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.
- 스트림 병렬화는 오직 성능 최적화 수단임을 기억해야 한다. 다른 최적화와 마찬가지로 변경 전후로 반드시 성능을 테스트하여 병렬화를 사용할 가치가 있는지 확인해야 한다. 이상적으로는 운영 시스템과 흡사한 환경에 서 테스트하는 것이 좋다. 보통은 병렬 스트림 파이프라인도 공통의 포크-조인 풀에서 수행되므로(즉, 같은 스레드 풀을 사용하므로), 잘못된 파이프라인 하나가 시스템의 다른 부분의 성능에까지 악영향을 줄 수 있음을 유념하자.