---
published: true
title: "이펙티브자바 6장  - 열거 타입과 애너테이션."
categories:
  - java
tags:
  - effective java
toc: true
toc_sticky: true
toc_label: ""
toc_icon: ""
---

이펙티브 자바를 보고 정리한 글 입니다. 이전에 패스트 캠퍼스를 보고 배웠던 Enum에 abstract 메서드를 사용하는 부분이 나와서 반가웠습니다 ^^.

---

### int 상수 대신 열거타입을 사용하라

- 열거 타입은 일정 개수의 상수값을 정의한 다음, 그 외의 값은 허용하지 않는 타입이다.
  사계절, 태양계의 행성, 카드게임의 카드 종류 등이 좋은 예시다.
- 열거 타입 자체는 클래 이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 Pubic static final 필드로 공개한다. 열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 final이다. 따라서 클라이언트가 인스턴스를 직접 생성하거나 확장 할 수 없으니 열거 타입 선언으로 만들어진 인스턴스들은 딱 하나씩만 존재함이 보장된다. 다시 말해 열거 타입은 인스턴스 통제된다. 싱글턴은 원소가 하나뿐인 열거 타입이라 할 수 있고, 거꾸로 열거 타입은 싱글턴을 일반화한 형태라고 볼 수 있다.
  열거 타입은 컴파일타임 타입 안전성을 제공한다.
- 열거 타입에 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다. 공개되는 것이 오직 필드의 이름뿐이라, 정수 열거 패턴과 달리 상수 값이 클라이언트로 컴파일되어 각인되지 않기 때문이다. 마지막으로 열거 타입의 tostring 메서드는 출력하기에 적합한 문자열을 내어준다!
  열거 타입에는 임의의 메서드나 필드를 추가할 수 있고 임의의 인터페이스를 구현하게 할 수도 있다.

```java
public enum Planet {
MERCURY (3.302+23, 2.4396), VENUS (4.869+24, 6.0526), EARTH (5.975+24, 6.3786),
MARS
(6.419+23, 3.3936),
JUPITER (1.899+27, 7.1497), SATURN (5.685+26, 6.0277), URANUS (8.683e+25, 2.556e7), NEPTUNE (1.024+26, 2.4777);
private final double mass;
// 질량(단위: 킬로그램)
private final double radius;
// 반지름(단위: 미터)
private final double surfaceGravity; // 표면중력(단위: m / 5^2)
// 중력상수(단위: m^3/ kg 5^2)
private static final double G = 6.67300-11;
// 생성자
Planet (double mass, double radius) {
thi.mass = mass;
this.radius = radius;
surfaceGravity = G * mass / (radius * radius);
public double mass() { return mass; }
public double radius() { return radius; }
public double surfaceGravity() { return surfaceGravity; }

public double surfaceWeight (double mass) {
	return mass * surfaceGravity; // F = ma
	}
}
```

- 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.

```java
public class WeightTable {
	public static void main(String[] args) {
		double earthWeight = Double.parseDouble(args[0]);
		double mass = earthWeight / Planet.EARTH.surfaceGravity();
		for (Planet p: Planet.values ())
			System.out.printf("%에서의 무게는 %f이다. %n",
													p, p. surfaceWeight (mass));
	}
}
```

- 열거 타입은 자신 안에 정의된 상수들의 값을 배열에 담아 반환하는 정적 메서드인 values를 제공한다. 값들은 선언된 순서로 저장된다. 각 열거 타입 값 의 tostring 메서드는 상수 이름을 문자열로 반환하므로 println과 printf로 출력하기에 안성맞춤이다. 기본 tostring이 제공하는 이름이 내키지 않으면 원하는 대로 재정의하면 된다. 다음은 (tostring을 재정의하지 않고) 앞서의 WeightTable을 실행한 결과이다.

```java

MERCURY에서의 무게는 69.912739이다.
VENUS에서의 무게는 167.434436이다.
EARTH에서의 무게는 185. 000000이다.
MARS에서의 무게는 70226739이다.
JUPITER에서의 무게는 467,990696이다.
SATURN에서의 무게는 197, 120111이다.
URANUS에서의 무게는 167.398264이다.
NEPTUNE에서의 무게는 210. 208751이다.
```

- 다행히 열거 타입은 상수별로 다르게 동작하는 코드를 구현하는 더 나은 수 단을 제공한다. 열거 타입에 apply라는 추상 메서드를 선언하고 각 상수별 클 래스 몸체(constant-specific class body), 즉 각 상수에서 자신에 맞게 재정의하 는 방법이다. 이를 상수별 메서드 구현(constant-specific method implementa-tion)이라 한다.
  - 상수별 메서드 구현을 활용한 열거 타입

    ```java
    
    public enum Operation {
    	PLUS {public double apply(double x, double y) return x + y;}},
    	MINUS {public double apply(double x, double y) return x - y;}}, 
    	TIMES {public double apply(double x, double y) return x * y:}}, 
    	DIVIDE{public double apply(double x, double y) return x / y; }};
    	public abstract double apply(double x, double y);
    }
    ```

  - 상수별 클래스 몸체와 데이터를 사용한 열거 타입

    ```java
    public enum Operation {
    PLUS("+"') {
    	public double apply(double X, double y) { return x + y; }
    MINUS("-") {
    	public double appLy(double X, double y) { return x - y: }
    TIMES("*") {
    	public double apply(double x, double y) { return x * y; }
    DEVIDE("/") {
    	public double apply(double x, double y) {return x / y; }
    };
    
    	private final String symbol;
    	Operation(String symbol) { this. symbol = symbol; }
    	@Override 
    	public String toString() { return symbol; } 
    	public abstract double apply(double x, double y);
    }
    
    다음은 이 tostring이 계산식 출력을 얼마나 편하게 해주는지를 보여준다.
    
    public static void main (String[] args) {
    	double x = Double.parseDouble(args [0]);
    	double y = Double.parseDouble(args [1]);
    	for (Operation op : Operation. values ())
    		System.out.printf ("%f %s %f = %f%n",
    												x, op, y, op.apply (x, y));
    }
    
    이제 명령줄 인수에 2와 4를 주어 이 프로그램을 실행하면 다음 결과를 볼 수 있다.
    
    2.000000 + 4.000000 = 6.000000
    2.000000 - 4.000000 = -2.000000
    2.000000 * 4.000000 = 8.000000
    2.000000 / 4.000000 = 0.500000
    ```

- 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.
- 핵심정리
  - 열거 타입은 확실히 정수 상수보다 뛰어나다. 더 읽기 쉽고 안전하고 강력하다. 대다수 열거 타입이 명시적 생성자나 메서드 없이 쓰이지만, 각 상수를 특정 데이터와 연결짓거나 상수마다 다르게 동작하게 할 때는 필요하다. 드물게는 하나의 메서드가 상수별로 다르게 동작해야 할 때도 있다. **이런 열거 타입에서는 Switch 문 대신 상수별 메서드 구현을 사용하자. 열거 타입 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 사 용하자.**